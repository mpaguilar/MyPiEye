import httplib2
import socket
import sys

from six.moves import BaseHTTPServer
from six.moves import http_client
from six.moves import input
from six.moves import urllib

from oauth2client import _helpers

from apiclient import discovery
from oauth2client import client
from oauth2client.file import Storage

import googleapiclient.errors
from os.path import exists, basename

import logging

_CLIENT_SECRETS_MESSAGE = """WARNING: Please configure OAuth 2.0

To make this sample run you will need to populate the client_secrets.json file
found at:

   {file_path}

with information from the APIs Console <https://code.google.com/apis/console>.

"""

_FAILED_START_MESSAGE = """
Failed to start a local webserver listening on either port 8080
or port 8090. Please check your firewall settings and locally
running programs that may be blocking or using those ports.

Falling back to --noauth_local_webserver and continuing with
authorization.
"""

_BROWSER_OPENED_MESSAGE = """
Your browser has been opened to visit:

    {address}

If your browser is on a different machine then exit and re-run this
application with the command-line parameter

  --noauth_local_webserver
"""

_GO_TO_LINK_MESSAGE = """
Go to the following link in your browser:

    {address}
"""

log = logging.getLogger(__name__)


def dump_list(items):
    for item in items:
        print('name: {} ({}) ({}) ({})'.format(
            item['name'], item['id'], item['mimeType'], item['parents']))


class ClientRedirectServer(BaseHTTPServer.HTTPServer):
    """A server to handle OAuth 2.0 redirects back to localhost.

    Waits for a single request and parses the query parameters
    into query_params and then stops serving.
    """
    query_params = {}


class ClientRedirectHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    """A handler for OAuth 2.0 redirects back to localhost.

    Waits for a single request and parses the query parameters
    into the servers query_params and then stops serving.
    """

    def do_GET(self):
        """Handle a GET request.

        Parses the query parameters and prints a message
        if the flow has completed. Note that we can't detect
        if an error occurred.
        """
        self.send_response(http_client.OK)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        parts = urllib.parse.urlparse(self.path)
        query = _helpers.parse_unique_urlencoded(parts.query)
        self.server.query_params = query
        self.wfile.write(
            b'<html><head><title>Authentication Status</title></head>')
        self.wfile.write(
            b'<body><p>The authentication flow has completed.</p>')
        self.wfile.write(b'</body></html>')


class GDrive:
    """
    Uploads files to Google drive
    """

    def __init__(self, scopes, app_name, app_secret_file, user_secret_file=None):
        """
        Constructor

        :param scopes: Google file scopes
        :param app_name: Registered Google application name
        :param app_secret_file: Secret file for app from Google
        :param user_secret_file: Secret file for user, generated by user
        """
        self.scopes = scopes
        self.app_name = app_name
        self.app_secret_file = app_secret_file
        self.user_secret_file = user_secret_file
        self.service = None

        # suppress irrelevant import warnings
        logging.disable(logging.ERROR)
        self.init_service()
        logging.disable(logging.NOTSET)

    def init_service(self):
        """
        Initializes credentials and service

        :return: None
        """
        credentials = self.get_credentials()
        http = credentials.authorize(httplib2.Http())
        self.service = discovery.build('drive', 'v3', http=http)

    def run_flow(self, flow, storage, http=None,
                 local_webserver=True, auth_host_name='localhost', auth_host_port=[8080]):
        port_number = 0
        httpd = None

        # if http is None:
        #     http = httplib2.Http.request

        if local_webserver:
            success = False

            for port in auth_host_port:
                port_number = port
                try:
                    httpd = ClientRedirectServer((auth_host_name, port),
                                                 ClientRedirectHandler)
                except socket.error:
                    pass
                else:
                    success = True
                    break
            local_webserver = not success
            if not success:
                log.critical(_FAILED_START_MESSAGE)

        if local_webserver:
            oauth_callback = 'http://{host}:{port}/'.format(
                host=auth_host_name, port=port_number)
        else:
            oauth_callback = client.OOB_CALLBACK_URN
        flow.redirect_uri = oauth_callback
        authorize_url = flow.step1_get_authorize_url()

        if local_webserver:
            import webbrowser
            webbrowser.open(authorize_url, new=1, autoraise=True)
            print(_BROWSER_OPENED_MESSAGE.format(address=authorize_url))
        else:
            print(_GO_TO_LINK_MESSAGE.format(address=authorize_url))

        if local_webserver:
            httpd.handle_request()
            if 'error' in httpd.query_params:
                sys.exit('Authentication request was rejected.')
            if 'code' in httpd.query_params:
                code = httpd.query_params['code']
            else:
                log.critical('Failed to find "code" in the query parameters '
                             'of the redirect.')
                sys.exit('Try running with --noauth_local_webserver.')
        else:
            code = input('Enter verification code: ').strip()

        try:
            credential = flow.step2_exchange(code, http=http)
        except client.FlowExchangeError as e:
            sys.exit('Authentication has failed: {0}'.format(e))

        storage.put(credential)
        credential.set_store(storage)
        log.info('Authentication successful.')

        return credential

    def get_credentials(self):
        """
        Gets credentials, going through OAuth flow if necessary,
        and authorizes the app.

        :return: credentials for service
        """

        store = Storage(self.user_secret_file)
        credentials = store.get()
        if not credentials or credentials.invalid:
            flow = client.flow_from_clientsecrets(
                self.app_secret_file, self.scopes)
            flow.user_agent = self.app_name

            credentials = self.run_flow(flow, store)

            log.warning('Storing credentials to ' + self.user_secret_file)
        return credentials

    def execute(self, query):
        """
        Queries google for specific items.

        :param query: Google query API string
        :return: All results
        """
        logging.disable(logging.WARN)
        ret = []

        listexp = {
            'pageSize': 1000,
            'fields': 'nextPageToken, files(id, name, mimeType, parents)',
            'q': query
        }

        results = self.service.files().list(**listexp).execute()
        nextp = results.get('nextPageToken', None)
        ret = ret + results.get('files', [])

        while nextp:
            log.debug('next page...')
            listexp['pageToken'] = nextp
            results = self.service.files().list(**listexp).execute()
            nextp = results.get('nextPageToken', None)
            ret = ret + results.get('files', [])
        logging.disable(logging.NOTSET)

        return ret

    def get_item(self, name, parent):
        query = 'name = "{}" and parents in "{}" and trashed = false'.format(name, parent['id'])
        vals = self.execute(query)
        if 0 == len(vals):
            return None

        file_obj = self.service.files().get(fileId=vals[0]['id']).execute()

        return file_obj

    def list_files(self, parent_name='root'):
        query = 'not mimeType="application/vnd.google-apps.folder" and parents in "{}"'.format(
            parent_name)
        return self.execute(query)

    def path_item(self, path):
        parts = path.split('/')
        item = {'id': 'root'}
        for ndx, p in enumerate(parts):
            if p == '':
                continue
            item = self.get_item(p, item)
            if item is None:
                if ndx != len(parts) - 1:
                    return None
                break
        return item

    def walk_path(self, path):
        ret = None

        parts = path.split('/')
        item = {'id': 'root'}
        for ndx, p in enumerate(parts):
            path_id = item['id']

            if p == '':
                continue

            item = self.get_item(p, item)

            if not item or (ndx == len(parts) - 1):
                ret = (path_id, '/'.join(parts[ndx:]))
                break

        return ret

    def mkpath(self, path):

        wp = self.walk_path(path)
        parent_id, not_found = wp

        item = {'id': parent_id}
        parts = not_found.split('/')

        for p in parts:
            if '' == p:
                continue

            parent_id = self.mkfolder(item['id'], p)
            log.warning('created folder with parent_id: {}'.format(parent_id))
            item = {'id': parent_id}

        return item

    def mkfolder(self, parent_id, folder_name):

        metadata = {
            'name': folder_name,
            'mimeType': 'application/vnd.google-apps.folder',
            'parents': [parent_id]
        }

        log.warning('making folder ' + folder_name + ' in folder_id ' + parent_id)

        ret = self.service.files().create(body=metadata, fields='id'). \
            execute()

        return ret['id']

    def put_image(self, image_path, folder_path, force=False):
        # until I figure out how to do it...

        force = False

        log.debug('Uploading...')
        if not exists(image_path):
            log.error("Image does not exist: {}".format(image_path))
            return None

        folder = self.path_item(folder_path)

        if folder is None:
            folder = self.mkpath(folder_path)

        if not folder and not force:
            log.error("Google folder not found: {}".format(folder_path))
            return None

        log.info("Uploading {} to folder id: {}".format(image_path, folder['id']))

        file_metadata = {
            'name': basename(image_path),
            'mimetype': 'image/jpeg',
            'parents': [folder['id']]
        }

        try:
            ret = self.service.files().create(body=file_metadata, media_body=image_path,
                                              media_mime_type='image/jpeg').execute()
            log.debug(ret)
        except googleapiclient.errors.HttpError as err:
            log.error("Error uploading: {}".format(err))


# If scope changes, delete previously saved creds
SCOPES = 'https://www.googleapis.com/auth/drive'
APPLICATION_NAME = 'MyPiEye Motion Detection'

